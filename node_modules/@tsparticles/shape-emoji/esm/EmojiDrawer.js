import { executeOnSingleOrMultiple, getRangeMax, isInArray, itemFromSingleOrMultiple, loadFont, } from "@tsparticles/engine";
export const validTypes = ["emoji"];
const defaultFont = '"Twemoji Mozilla", Apple Color Emoji, "Segoe UI Emoji", "Noto Color Emoji", "EmojiOne Color"';
export class EmojiDrawer {
    constructor() {
        this._emojiShapeDict = new Map();
    }
    destroy() {
        for (const [, emojiData] of this._emojiShapeDict) {
            emojiData instanceof ImageBitmap && emojiData?.close();
        }
    }
    draw(data) {
        const { context, particle, radius, opacity } = data, emojiData = particle.emojiData;
        if (!emojiData) {
            return;
        }
        context.globalAlpha = opacity;
        context.drawImage(emojiData, -radius, -radius, radius * 2, radius * 2);
        context.globalAlpha = 1;
    }
    async init(container) {
        const options = container.actualOptions;
        if (validTypes.find((t) => isInArray(t, options.particles.shape.type))) {
            const promises = [loadFont(defaultFont)], shapeOptions = validTypes
                .map((t) => options.particles.shape.options[t])
                .find((t) => !!t);
            if (shapeOptions) {
                executeOnSingleOrMultiple(shapeOptions, (shape) => {
                    shape.font && promises.push(loadFont(shape.font));
                });
            }
            await Promise.all(promises);
        }
    }
    particleDestroy(particle) {
        delete particle.emojiData;
    }
    particleInit(container, particle) {
        if (!particle.emojiData) {
            const shapeData = particle.shapeData;
            if (!shapeData?.value) {
                return;
            }
            const emoji = itemFromSingleOrMultiple(shapeData.value, particle.randomIndexData), font = shapeData.font ?? defaultFont;
            if (!emoji) {
                return;
            }
            const key = `${emoji}_${font}`, existingData = this._emojiShapeDict.get(key);
            if (existingData) {
                particle.emojiData = existingData;
                return;
            }
            const canvasSize = getRangeMax(particle.size.value) * 2;
            let emojiData;
            if (typeof OffscreenCanvas !== "undefined") {
                const canvas = new OffscreenCanvas(canvasSize, canvasSize), context = canvas.getContext("2d");
                if (!context) {
                    return;
                }
                context.font = `400 ${getRangeMax(particle.size.value) * 2}px ${font}`;
                context.textBaseline = "middle";
                context.textAlign = "center";
                context.fillText(emoji, getRangeMax(particle.size.value), getRangeMax(particle.size.value));
                emojiData = canvas.transferToImageBitmap();
            }
            else {
                const canvas = document.createElement("canvas");
                canvas.width = canvasSize;
                canvas.height = canvasSize;
                const context = canvas.getContext("2d");
                if (!context) {
                    return;
                }
                context.font = `400 ${getRangeMax(particle.size.value) * 2}px ${font}`;
                context.textBaseline = "middle";
                context.textAlign = "center";
                context.fillText(emoji, getRangeMax(particle.size.value), getRangeMax(particle.size.value));
                emojiData = canvas;
            }
            this._emojiShapeDict.set(key, emojiData);
            particle.emojiData = emojiData;
        }
    }
}
